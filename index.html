<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dragon's World</title>
  <style>
    body { margin: 0; background: #0d0a1a; font-family: 'Segoe UI', sans-serif; text-align: center; color: #fff; }
    h1 { font-size: 4em; margin: 0.4em 0 0.1em;
      background: linear-gradient(90deg, red, orange, yellow, green, #00cfff, violet);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    h2 { font-size: 1.4em; color: #ccc; margin-bottom: 1.5em; letter-spacing: 2px; }
    .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
      max-width: 860px; margin: 0 auto 3em; padding: 0 20px; }
    .card { border-radius: 16px; padding: 24px 16px;
      transition: transform 0.2s, box-shadow 0.2s; border: 2px solid rgba(255,255,255,0.15); }
    .card:hover { transform: translateY(-6px) scale(1.03); box-shadow: 0 12px 32px rgba(0,0,0,0.5); }
    .icon { font-size: 3em; margin-bottom: 10px; }
    .card h3 { margin: 0 0 6px; font-size: 1.3em; }
    .element { font-size: 0.85em; font-weight: bold; text-transform: uppercase;
      letter-spacing: 1px; opacity: 0.85; margin-bottom: 8px; }
    .ability { font-size: 0.82em; color: #eee; line-height: 1.4; }
    .btn-play { margin-top: 14px; padding: 8px 24px; border: none; border-radius: 20px;
      background: rgba(255,255,255,0.2); color: #fff; font-size: 0.9em; font-weight: bold;
      cursor: pointer; letter-spacing: 1px; transition: background 0.2s; }
    .btn-play:hover { background: rgba(255,255,255,0.4); }
    .emberclaw  { background: linear-gradient(145deg, #3a0000, #8b1a00); }
    .frostfang  { background: linear-gradient(145deg, #00204a, #1a6ea8); }
    .tidesong   { background: linear-gradient(145deg, #002a2a, #0a6b6b); }
    .verdenwing { background: linear-gradient(145deg, #0a2200, #235e00); }
    .stormtalon { background: linear-gradient(145deg, #2a2200, #7a6000); }
    .shadowmend { background: linear-gradient(145deg, #1a002a, #4b0080); }
    @media (max-width: 600px) { .grid { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 2.6em; } }
    #game { display: none; flex-direction: column; align-items: center; padding: 20px 0; }
    #game-title { font-size: 1.3em; color: #ccc; margin-bottom: 10px; }
    #canvas { border: 2px solid #444; border-radius: 8px; display: block; max-width: 100%; cursor: default; }
    #back-btn { margin-top: 14px; padding: 8px 22px; border: none; border-radius: 20px;
      background: rgba(255,255,255,0.15); color: #fff; font-size: 0.9em; cursor: pointer; }
    #back-btn:hover { background: rgba(255,255,255,0.3); }
  </style>
</head>
<body>
  <div id="selection">
    <h1>Dragon's World</h1>
    <h2>Choose Your Dragon</h2>
    <div class="grid">
      <div class="card emberclaw">
        <div class="icon">üî•</div>
        <h3>Emberclaw</h3>
        <div class="element" style="color:#ff6a00;">Fire</div>
        <div class="ability">Breathes a blazing inferno that melts anything in its path!</div>
        <button class="btn-play" data-color="#ff4400">‚ñ∂ Play</button>
      </div>
      <div class="card frostfang">
        <div class="icon">‚ùÑÔ∏è</div>
        <h3>Frostfang</h3>
        <div class="element" style="color:#7dd6ff;">Ice</div>
        <div class="ability">Freezes enemies solid with one mighty icy roar!</div>
        <button class="btn-play" data-color="#7dd6ff">‚ñ∂ Play</button>
      </div>
      <div class="card tidesong">
        <div class="icon">üåä</div>
        <h3>Tidesong</h3>
        <div class="element" style="color:#00e5c8;">Ocean</div>
        <div class="ability">Summons massive waves with a melodic battle cry!</div>
        <button class="btn-play" data-color="#00e5c8">‚ñ∂ Play</button>
      </div>
      <div class="card verdenwing">
        <div class="icon">üåø</div>
        <h3>Verdenwing</h3>
        <div class="element" style="color:#5ddb3a;">Forest</div>
        <div class="ability">Grows enchanted vines to trap foes and heal allies!</div>
        <button class="btn-play" data-color="#5ddb3a">‚ñ∂ Play</button>
      </div>
      <div class="card stormtalon">
        <div class="icon">‚ö°</div>
        <h3>Stormtalon</h3>
        <div class="element" style="color:#ffe033;">Sky</div>
        <div class="ability">Calls down lightning bolts from thundering storm clouds!</div>
        <button class="btn-play" data-color="#ffe033">‚ñ∂ Play</button>
      </div>
      <div class="card shadowmend">
        <div class="icon">üåë</div>
        <h3>Shadowmend</h3>
        <div class="element" style="color:#c87aff;">Dark</div>
        <div class="ability">Vanishes into darkness and strikes from the shadows!</div>
        <button class="btn-play" data-color="#c87aff">‚ñ∂ Play</button>
      </div>
    </div>
  </div>

  <div id="game">
    <div id="game-title"></div>
    <canvas id="canvas" width="800" height="500"></canvas>
    <button id="back-btn">‚Üê Back to Selection</button>
  </div>

  <script>
    const sel = document.getElementById('selection'), gameDiv = document.getElementById('game');
    const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, MAP = 2000, CD = 10000;

    const ZONES = [
      { label: 'Volcanic Wastes', color: '#5a1000', x: 0,    y: 0,    w: 1000, h: 1000 },
      { label: 'Glacial Peaks',   color: '#082240', x: 1000, y: 0,    w: 1000, h: 1000 },
      { label: 'Sunken Reef',     color: '#003020', x: 0,    y: 1000, w: 1000, h: 1000 },
      { label: 'Ancient Canopy',  color: '#052000', x: 1000, y: 1000, w: 1000, h: 1000 },
    ];

    // [fracX, fracY, radius] within each zone
    const OBS_POS = [
      [[.18,.28,28],[.68,.18,22],[.42,.62,32],[.78,.52,18],[.12,.75,26],[.52,.38,20]],
      [[.22,.22,22],[.60,.16,26],[.38,.64,20],[.74,.50,24],[.48,.78,22],[.14,.50,18]],
      [[.28,.24,20],[.64,.34,18],[.20,.64,24],[.70,.68,26],[.45,.46,16],[.84,.18,22]],
      [[.18,.38,30],[.60,.22,24],[.40,.74,20],[.74,.56,28],[.10,.18,18],[.54,.84,22]],
    ];
    const OBS_FILL = ['#7a1a00','#1a3a55','#004433','#0e3a00'];
    const OBS_GLOW = ['#ff5500','#77bbff','#00cc88','#44cc00'];

    const ABILITY_LABEL = {
      Emberclaw:'Fire Blast', Frostfang:'Ice Wall', Tidesong:'Speed Boost',
      Verdenwing:'Invisibility', Stormtalon:'Dash', Shadowmend:'Freeze All'
    };

    let state, player, wyrms, obstacles, eggs, goldenEgg, blasts, cam, startTime, elapsed, animId;
    let keys = {}, currentName = '';

    function makeObs() {
      const obs = [];
      ZONES.forEach((z, zi) => OBS_POS[zi].forEach(([fx, fy, r]) =>
        obs.push({ x: z.x + z.w * fx, y: z.y + z.h * fy, r, destroyed: false,
                   fill: OBS_FILL[zi], glow: OBS_GLOW[zi] })
      ));
      return obs;
    }

    function makeWyrms() {
      const t = Date.now() + 4000; // first Thornwyrm teleport delay
      return [
        { x:150,  y:150,  r:16, bR:16, speed:2.0,  bS:2.0,  fill:'#aa1100', glow:'#ff4400', zone:0, frozen:0, gt:0 },
        { x:1850, y:150,  r:26, bR:26, speed:0.65, bS:0.65, fill:'#cce8ff', glow:'#99ccff', zone:1, frozen:0, gt:0 },
        { x:150,  y:1850, r:16, bR:16, speed:1.3,  bS:1.3,  fill:'#00aa88', glow:'#00ffcc', zone:2, frozen:0, gt:0, wave:0 },
        { x:1850, y:1850, r:16, bR:16, speed:1.4,  bS:1.4,  fill:'#1a5500', glow:'#44cc00', zone:3, frozen:0, gt:0, tCD:t },
      ];
    }

    function initGame(color, name) {
      state = 'playing'; currentName = name;
      player = { x:MAP/2, y:MAP/2, r:12, color, speed:3.5, name,
                 abCD:0, speedBoost:0, invis:0, facing:{x:1,y:0} };
      wyrms = makeWyrms(); obstacles = makeObs(); blasts = [];
      eggs = ZONES.map((z, zi) => ({
        x: z.x + 100 + Math.random() * (z.w - 200),
        y: z.y + 100 + Math.random() * (z.h - 200),
        r: 10, collected: false, zone: zi
      }));
      goldenEgg = null; cam = { x:0, y:0 }; startTime = Date.now(); elapsed = 0;
      document.getElementById('game-title').textContent =
        `${name} ‚Äî SPACE: ${ABILITY_LABEL[name]} (10s CD) | Collect 4 zone eggs, then the Golden Egg!`;
    }

    function circ(x, y, r, fill, stroke, lw) {
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = fill; ctx.fill();
      if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw || 2; ctx.stroke(); }
    }

    // Returns true if (x,y) with radius r doesn't overlap any active obstacle
    function free(x, y, r) {
      for (const o of obstacles) if (!o.destroyed && Math.hypot(x - o.x, y - o.y) < r + o.r) return false;
      return true;
    }

    function useAbility() {
      const now = Date.now();
      if (now < player.abCD) return;
      player.abCD = now + CD;
      const { x: fx, y: fy } = player.facing;
      switch (player.name) {
        case 'Emberclaw':
          blasts.push({ x: player.x, y: player.y, dx: fx, dy: fy, r: 7, spd: 11 }); break;
        case 'Frostfang':
          obstacles.push({ x: player.x - fx * 44, y: player.y - fy * 44, r: 26, destroyed: false,
                           expires: now + 3000, fill: '#aadeff', glow: '#ffffff', temp: true }); break;
        case 'Tidesong':  player.speedBoost = now + 3000; break;
        case 'Verdenwing': player.invis = now + 4000; break;
        case 'Stormtalon': {
          const nx = Math.max(player.r, Math.min(MAP - player.r, player.x + fx * 230));
          const ny = Math.max(player.r, Math.min(MAP - player.r, player.y + fy * 230));
          if (free(nx, ny, player.r)) { player.x = nx; player.y = ny; } break;
        }
        case 'Shadowmend': wyrms.forEach(w => w.frozen = now + 5000); break;
      }
    }

    function updateWyrm(w, now) {
      if (w.frozen > now) return;
      const z = ZONES[w.zone];
      // If player is invisible, wyrm wanders toward zone centre instead
      const tx = player.invis > now ? z.x + z.w / 2 : player.x;
      const ty = player.invis > now ? z.y + z.h / 2 : player.y;
      let dx = tx - w.x, dy = ty - w.y, d = Math.hypot(dx, dy) || 1;
      let mx = 0, my = 0;

      if (w.wave !== undefined) {           // Tidewyrm ‚Äî sinusoidal weave
        w.wave += 0.05;
        const a = Math.atan2(dy, dx), px = Math.cos(a + 1.5708), py = Math.sin(a + 1.5708);
        mx = (dx / d) * w.speed + px * Math.sin(w.wave) * 2.5;
        my = (dy / d) * w.speed + py * Math.sin(w.wave) * 2.5;
      } else if (w.tCD !== undefined) {     // Thornwyrm ‚Äî teleport bursts
        if (now > w.tCD && d > 180) {
          w.tCD = now + 3000;
          const leap = 120 + Math.random() * 110;
          w.x = Math.max(z.x + w.r, Math.min(z.x + z.w - w.r, w.x + (dx / d) * leap));
          w.y = Math.max(z.y + w.r, Math.min(z.y + z.h - w.r, w.y + (dy / d) * leap));
        }
        mx = (dx / d) * w.speed; my = (dy / d) * w.speed;
      } else {
        mx = (dx / d) * w.speed; my = (dy / d) * w.speed;
      }

      w.x += mx; w.y += my;

      // Push wyrm away from temporary ice-wall obstacles
      for (const o of obstacles) {
        if (!o.destroyed && o.temp) {
          const od = Math.hypot(w.x - o.x, w.y - o.y) || 1;
          if (od < w.r + o.r) {
            const push = (w.r + o.r - od + 1) / od;
            w.x += (w.x - o.x) * push; w.y += (w.y - o.y) * push;
          }
        }
      }

      // Clamp to zone
      w.x = Math.max(z.x + w.r, Math.min(z.x + z.w - w.r, w.x));
      w.y = Math.max(z.y + w.r, Math.min(z.y + z.h - w.r, w.y));

      // 20% growth every 30 s
      const gs = Math.floor(elapsed / 30);
      if (gs > w.gt) { w.gt = gs; w.r = w.bR * (1 + gs * 0.2); w.speed = w.bS * (1 + gs * 0.2); }
    }

    function drawGame() {
      const now = Date.now(), t = now / 400;
      cam.x = Math.max(0, Math.min(MAP - W, player.x - W / 2));
      cam.y = Math.max(0, Math.min(MAP - H, player.y - H / 2));
      ctx.save(); ctx.translate(-cam.x, -cam.y);

      // Zone backgrounds + labels
      ZONES.forEach(z => {
        ctx.fillStyle = z.color; ctx.fillRect(z.x, z.y, z.w, z.h);
        ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.font = 'bold 38px Segoe UI';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(z.label, z.x + z.w / 2, z.y + z.h / 2);
      });

      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
      for (let i = 0; i <= MAP; i += 100) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, MAP); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(MAP, i); ctx.stroke();
      }

      // Obstacles
      obstacles.forEach(o => {
        if (o.destroyed) return;
        ctx.save(); ctx.shadowColor = o.glow; ctx.shadowBlur = o.temp ? 20 : 10;
        circ(o.x, o.y, o.r, o.fill, o.glow, 2); ctx.restore();
      });

      // Zone eggs
      eggs.forEach(egg => {
        if (egg.collected) return;
        ctx.save(); ctx.shadowColor = '#ffe066'; ctx.shadowBlur = 14 + Math.sin(t) * 7;
        circ(egg.x, egg.y, egg.r, '#fffab0', '#ffe066', 2); ctx.restore();
      });

      // Golden egg
      if (goldenEgg && !goldenEgg.collected) {
        ctx.save(); ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 24 + Math.sin(t * 1.5) * 10;
        circ(goldenEgg.x, goldenEgg.y, 15, '#ffd700', '#ffffff', 3); ctx.restore();
      }

      // Fire blasts
      blasts.forEach(b => {
        ctx.save(); ctx.shadowColor = '#ff6600'; ctx.shadowBlur = 16;
        circ(b.x, b.y, b.r, '#ff8800', '#ffcc00', 2); ctx.restore();
      });

      // Wyrms
      wyrms.forEach(w => {
        ctx.save(); ctx.shadowColor = w.glow; ctx.shadowBlur = 22;
        if (w.frozen > now) ctx.globalAlpha = 0.4;
        circ(w.x, w.y, w.r, w.fill, w.glow, 3); ctx.restore();
      });

      // Player (semi-transparent when invisible)
      ctx.save();
      if (player.invis > now) ctx.globalAlpha = 0.28;
      ctx.shadowColor = player.color; ctx.shadowBlur = 20;
      circ(player.x, player.y, player.r, player.color, '#fff', 2); ctx.restore();

      ctx.restore(); // end camera

      // ‚îÄ‚îÄ HUD ‚îÄ‚îÄ
      const coll = eggs.filter(e => e.collected).length;
      const mins = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const secs = String(elapsed % 60).padStart(2, '0');
      ctx.fillStyle = 'rgba(0,0,0,0.68)'; ctx.fillRect(8, 8, 248, 96);
      ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Segoe UI';
      ctx.textAlign = 'left'; ctx.textBaseline = 'top';
      ctx.fillText(`Time: ${mins}:${secs}`, 18, 14);
      ctx.fillText(`Zone Eggs: ${coll}/4${goldenEgg ? '  ‚òÖ Golden Egg on map!' : ''}`, 18, 34);
      const cdLeft = Math.max(0, Math.ceil((player.abCD - now) / 1000));
      ctx.fillStyle = cdLeft ? '#ff9944' : '#88ff55';
      ctx.fillText(`SPACE: ${ABILITY_LABEL[player.name]}${cdLeft ? ` (${cdLeft}s)` : ' ‚Äî READY'}`, 18, 54);
      const fx = [];
      if (player.speedBoost > now) fx.push(`Boost ${Math.ceil((player.speedBoost - now) / 1000)}s`);
      if (player.invis > now)      fx.push(`Invis ${Math.ceil((player.invis - now) / 1000)}s`);
      const maxFrz = Math.max(...wyrms.map(w => w.frozen));
      if (maxFrz > now) fx.push(`Freeze ${Math.ceil((maxFrz - now) / 1000)}s`);
      if (fx.length) { ctx.fillStyle = '#88ffff'; ctx.fillText('‚ñ∂ ' + fx.join(' | '), 18, 74); }

      // ‚îÄ‚îÄ Game over / win overlay ‚îÄ‚îÄ
      if (state !== 'playing') {
        ctx.fillStyle = 'rgba(0,0,0,0.76)'; ctx.fillRect(0, 0, W, H);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.font = 'bold 54px Segoe UI';
        ctx.fillStyle = state === 'win' ? '#ffd700' : '#ff3344';
        ctx.fillText(state === 'win' ? 'üèÜ YOU WIN!' : 'üíÄ GAME OVER', W / 2, H / 2 - 58);
        ctx.font = '20px Segoe UI'; ctx.fillStyle = '#ccc';
        ctx.fillText(`Time: ${mins}:${secs}  ‚Ä¢  Zone Eggs: ${coll}/4`, W / 2, H / 2 + 2);
        ctx.fillStyle = '#fff'; ctx.fillRect(W / 2 - 80, H / 2 + 36, 160, 46);
        ctx.fillStyle = '#111'; ctx.font = 'bold 18px Segoe UI';
        ctx.fillText('Play Again', W / 2, H / 2 + 59);
      }
    }

    function loop() {
      const now = Date.now();
      if (state === 'playing') {
        elapsed = Math.floor((now - startTime) / 1000);

        // Movement (separated axes for obstacle sliding)
        const fx = (keys['ArrowRight'] || keys['d'] || keys['D'] ? 1 : 0)
                 - (keys['ArrowLeft']  || keys['a'] || keys['A'] ? 1 : 0);
        const fy = (keys['ArrowDown']  || keys['s'] || keys['S'] ? 1 : 0)
                 - (keys['ArrowUp']    || keys['w'] || keys['W'] ? 1 : 0);
        const fd = Math.hypot(fx, fy) || 1;
        if (fx || fy) player.facing = { x: fx / fd, y: fy / fd };
        const sp = player.speed * (player.speedBoost > now ? 2 : 1);
        const nx = Math.max(player.r, Math.min(MAP - player.r, player.x + (fx / fd) * sp * (fx || fy ? 1 : 0)));
        const ny = Math.max(player.r, Math.min(MAP - player.r, player.y + (fy / fd) * sp * (fx || fy ? 1 : 0)));
        if (free(nx, player.y, player.r)) player.x = nx;
        if (free(player.x, ny, player.r)) player.y = ny;

        // Fire blasts ‚Äî move, check obstacle hit, expire at map edge
        blasts = blasts.filter(b => {
          b.x += b.dx * b.spd; b.y += b.dy * b.spd;
          const hit = obstacles.find(o => !o.destroyed && !o.temp &&
                                         Math.hypot(b.x - o.x, b.y - o.y) < b.r + o.r);
          if (hit) { hit.destroyed = true; return false; }
          return b.x >= 0 && b.x <= MAP && b.y >= 0 && b.y <= MAP;
        });

        // Expire temporary obstacles (ice walls)
        obstacles = obstacles.filter(o => !o.expires || o.expires > now);

        wyrms.forEach(w => updateWyrm(w, now));

        // Collect zone eggs
        eggs.forEach(e => {
          if (!e.collected && Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r)
            e.collected = true;
        });

        // Spawn golden egg once all 4 zone eggs collected
        if (!goldenEgg && eggs.every(e => e.collected))
          goldenEgg = { x: 120 + Math.random() * (MAP - 240), y: 120 + Math.random() * (MAP - 240),
                        r: 15, collected: false };

        // Collect golden egg ‚Üí win
        if (goldenEgg && !goldenEgg.collected &&
            Math.hypot(player.x - goldenEgg.x, player.y - goldenEgg.y) < player.r + goldenEgg.r)
          { goldenEgg.collected = true; state = 'win'; }

        // Wyrm touches player ‚Üí game over (frozen wyrms don't count)
        if (state === 'playing' &&
            wyrms.some(w => w.frozen <= now && Math.hypot(player.x - w.x, player.y - w.y) < player.r + w.r))
          state = 'gameover';
      }
      drawGame();
      animId = requestAnimationFrame(loop);
    }

    // Play Again button hit-test
    canvas.addEventListener('click', e => {
      if (state !== 'win' && state !== 'gameover') return;
      const r = canvas.getBoundingClientRect();
      const cx = (e.clientX - r.left) * (W / r.width), cy = (e.clientY - r.top) * (H / r.height);
      if (cx > W/2 - 80 && cx < W/2 + 80 && cy > H/2 + 36 && cy < H/2 + 82)
        initGame(player.color, currentName);
    });

    document.querySelectorAll('.btn-play').forEach(btn => btn.addEventListener('click', e => {
      e.stopPropagation();
      initGame(btn.dataset.color, btn.closest('.card').querySelector('h3').textContent);
      sel.style.display = 'none'; gameDiv.style.display = 'flex';
      canvas.focus();
      if (animId) cancelAnimationFrame(animId);
      loop();
    }));

    document.getElementById('back-btn').addEventListener('click', () => {
      if (animId) { cancelAnimationFrame(animId); animId = null; }
      gameDiv.style.display = 'none'; sel.style.display = 'block';
    });

    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
      if (e.key === ' ' && state === 'playing') useAbility();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });
  </script>
</body>
</html>
